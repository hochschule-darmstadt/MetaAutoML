@inject IStringLocalizer<Global> L
@inject IApiClient apiClient
@inject IViewNotifier viewNotifier
@using Newtonsoft.Json
@using Radzen
@using Radzen.Blazor

<style>
    .strategy-description-tooltip {
        max-width: 330px;
    }
</style>

<MudStack>
    @switch (Dataset.Dataset.Type.ID)
    {
        case ":time_series_longitudinal":
        case ":text":
        case ":tabular":
        case ":time_series":
            <MudTimeline TimelineOrientation="@TimelineOrientation.Horizontal" TimelinePosition="@TimelinePosition.Bottom">
                <MudTimelineItem>
                    <MudText Align="Align.Center" Typo="Typo.body2">@L["Dataset preparation"]</MudText>
                </MudTimelineItem>
                <MudTimelineItem Color="Color.Secondary">
                    <MudText Align="Align.Center" Typo="Typo.body2">@L["Configuration"]</MudText>
                </MudTimelineItem>
            </MudTimeline>
            break;
        case ":image":
            <MudTimeline TimelineOrientation="@TimelineOrientation.Horizontal" TimelinePosition="@TimelinePosition.Bottom">
                <MudTimelineItem Color="Color.Secondary">
                    <MudText Align="Align.Center" Typo="Typo.body2">@L["Configuration"]</MudText>
                </MudTimelineItem>
            </MudTimeline>
            break;
    }

    <MudGrid>
        @if (_compatibleTasks != null)
        {
            <MudItem xs="12">
                <MudGrid>
                    <MudItem xs="13">
                        <LabelTooltip FontSize="TextStyle.H4" Text="Select the ML task, i.e., what the ML model shall predict, e.g., classes (classification) or values (regression)." Position="Radzen.TooltipPosition.Top"></LabelTooltip>
                    </MudItem>
                    <MudItem xs="11" data-form-fifthStep>
                        <MudSelect Label="@L["ML task"]" T="string" ValueChanged="@OnMlTaskSelectionChanged" Class="mud-width-full">

                            @foreach (var task in _compatibleTasks.Tasks)
                            {
                                <MudSelectItem Value="@task.ID">
                                    <ButtonTooltip Text=@task.Properties["rdfs:comment"] URL=@(task.Properties.ContainsKey("rdfs:seeAlso") ? task.Properties["rdfs:seeAlso"] : "") Position="Placement.Right">@L[task.Properties.ContainsKey("skos:prefLabel") ? task.Properties["skos:prefLabel"] : ""]</ButtonTooltip>
                                </MudSelectItem>



                            }
                        </MudSelect>
                    </MudItem>
                </MudGrid>
            </MudItem>
        }
        else
        {
            <DataLoaderSpinner />
        }

        @if (((Dataset.Dataset.Type.ID == ":tabular") || (Dataset.Dataset.Type.ID == ":text") || (Dataset.Dataset.Type.ID == ":time_series") || (Dataset.Dataset.Type.ID == ":time_series_longitudinal")) && (!string.IsNullOrEmpty(StartTrainingDto.Configuration.Task)) && (StartTrainingDto.Configuration.Task != ":tabular_clustering"))

        {
            <MudItem xs="12" data-form-sixthStep>
                <MudGrid>
                    <MudItem xs="13">
                        <LabelTooltip FontSize="TextStyle.H4" Text="Select which column in a tabular dataset is to be predicted by the ML model." Position="Radzen.TooltipPosition.Top"></LabelTooltip>
                    </MudItem>
                    <MudItem xs="11" >
                        <MudSelect Label="@L["target *"]" T="string" @bind-SelectedValues="SelectedTargets" MultiSelection="true">
                            @if (_columnNames != null)
                            {
                                @foreach (var column in _columnNames)
                                {
                                    <div style="display:block; height:fit-content">
                                        <MudSelectItem Value="@column">@column</MudSelectItem>
                                    </div>
                                }
                            }
                        </MudSelect>
                    </MudItem>
                </MudGrid>
            </MudItem>
        }
        <MudItem xs="12">
            <MudGrid>
                <MudItem xs="13">
                    <LabelTooltip FontSize="TextStyle.H4" Text="Specify the maximum runtime in minutes OMA-ML shall use for training. Longer runtimes tend to produce better models; shorter runtimes are more energy-efficient." Position="Radzen.TooltipPosition.Top"></LabelTooltip>
                </MudItem>
                <MudItem xs="11">
                    <MudNumericField ValueChanged="@OnRuntimeValueChanged" T="int" Label="@L["Runtime"]" Variant="MudBlazor.Variant.Text" Min="3" Max="640" Value="@StartTrainingDto.Configuration.RuntimeLimit" />
                </MudItem>
            </MudGrid>
        </MudItem>
        @if (!string.IsNullOrEmpty(StartTrainingDto.Configuration.Task) == true) //Only show details panel when task was selelected
        {
            <MudItem xs="11" data-form-seventhStep>
                <MudExpansionPanels>
                    <MudExpansionPanel>
                        <TitleContent>
                            <ButtonTooltip Text="Click here to open numerous detail configuration options." Position="Placement.Right">@L["Detail configuration (optional)"]</ButtonTooltip>
                        </TitleContent>
                        <ChildContent>
                            <MudSwitch @bind-Checked="@StartTrainingDto.PerformModelAnalysis" Label="@L["Perform model analysis"]" Color="Color.Info" />
                            <LabelTooltip Label=@L["ML libraries"] FontSize="TextStyle.Body1" Text="Select or deselect ML libraries for which ML models shall be generated. Initially, all ML libraries that are supported for the selected ML task are selected (indiated by a tick). When changing selections, corresponding AutoML solutions will be adapted automatically." Position="Radzen.TooltipPosition.Right"></LabelTooltip>

                            <ChipSet ViewModel="@_mlLibsViewModel" />
                            <LabelTooltip Label="@L["AutoML solutions"]" FontSize="TextStyle.Body1" Text="AutoML solutions generate ML models for certain ML libraries. Initially, all AutoML solutions are selected that are supported for the selected ML libraries. When changing selections, corresponding ML libraries will be adapted automatically." Position="Radzen.TooltipPosition.Right"></LabelTooltip>
                            <ChipSet ViewModel="@_autoMlSolutionsViewModel" />
                            <LabelTooltip Label="@L["Training strategies"]" FontSize="TextStyle.Body1" Text="Training strategies are intelligent helpers that perform best practices in data science for you automatically. Select strategies that you want to enable for this training. " Position="Radzen.TooltipPosition.Right"></LabelTooltip>
                            <ChipSet ViewModel="@_strategiesViewModel" />
                            @if (_intersectedParams.Any())
                            {
                                <LabelTooltip Label="Parameters" FontSize="TextStyle.Body1" Text="All AutoML solutions use default parameters for training. If you want to specify those parameters yourself you can do this here. " Position="Radzen.TooltipPosition.Right"></LabelTooltip>

                                @foreach (var param in _intersectedParams)
                                {
                                    @if (param.ParameterType == ":single_value")
                                    {
                                        <MudGrid>
                                            @if (string.IsNullOrEmpty(param.CommentPara) == false)
                                            {
                                                <MudItem xs="13">
                                                    <LabelTooltip FontSize="TextStyle.H4" Text="@param.CommentPara" Position="Radzen.TooltipPosition.Left"></LabelTooltip>
                                                </MudItem>
                                            }
                                            <MudItem xs="11">
                                                <MudSelect T="ParameterValueViewModel" Class="ml-2" Label="@param.ParameterLabel" Variant="MudBlazor.Variant.Outlined" @bind-SelectedValues="param.SelectedValues" ToStringFunc="p => p?.ValueLabel">
                                                    @foreach (var paramValue in param.ParameterValues)
                                                    {
                                                    <MudSelectItem Value="@paramValue">
                                                        <LabelTooltip FontSize="TextStyle.Body1" Icon="false" URL=@paramValue.SeeAlsoValue Label=@paramValue.ValueLabel Text=@paramValue.CommentValue Position="Radzen.TooltipPosition.Right"></LabelTooltip>
                                                    </MudSelectItem>
                                                    }
                                                </MudSelect>
                                            </MudItem>
                                        </MudGrid>
                                    }
                                    @if (param.ParameterType == ":list")
                                    {
                                        <MudGrid>
                                            @if (string.IsNullOrEmpty(param.CommentPara) == false)
                                            {
                                                <MudItem xs="13">
                                                    <LabelTooltip FontSize="TextStyle.H4" Text="@param.CommentPara" Position="Radzen.TooltipPosition.Left"></LabelTooltip>
                                                </MudItem>
                                            }
                                            <MudItem xs="11">
                                                <MudSelect T="ParameterValueViewModel" Class="ml-2" Label="@param.ParameterLabel" MultiSelection="true" SelectAll="true" @bind-SelectedValues="param.SelectedValues" ToStringFunc="p => p?.ValueLabel" Variant="MudBlazor.Variant.Outlined">
                                                    @foreach (var paramValue in param.ParameterValues)
                                                    {

                                                        <MudSelectItem Value="@paramValue">
                                                            <LabelTooltip FontSize="TextStyle.Body1" Icon="false" URL=@paramValue.SeeAlsoValue Label=@paramValue.ValueLabel Text=@paramValue.CommentValue Position="Radzen.TooltipPosition.Right"></LabelTooltip>
                                                        </MudSelectItem>
                                                    }
                                                </MudSelect>
                                            </MudItem>
                                        </MudGrid>
                                    }
                                    else if (param.ParameterType == ":integer")
                                    {
                                        <MudGrid>
                                            @if (string.IsNullOrEmpty(param.CommentPara) == false)
                                            {
                                                <MudItem xs="13">
                                                    <LabelTooltip FontSize="TextStyle.H4" Text="@param.CommentPara" Position="Radzen.TooltipPosition.Left"></LabelTooltip>
                                                </MudItem>
                                            }
                                            <MudItem xs="11">
                                                <MudNumericField T="int?" Class="ml-2" Label="@param.ParameterLabel" Variant="MudBlazor.Variant.Outlined" @bind-Value="@param.IntegerValue" />
                                            </MudItem>
                                        </MudGrid>
                                    }
                                }
                            }

                            @if (_individualParams.Any())
                            {
                                <LabelTooltip Label="@L["Parameters available for individual AutoML solution only"]" FontSize="TextStyle.Body1" Text="A number of configuration parameters are specific for individual AutoML solutions. Here you can specify them. If not specified individually, default configurations are used." Position="Radzen.TooltipPosition.Right"></LabelTooltip>

                                @foreach (var individualParam in _individualParams)
                                {
                                    <MudExpansionPanels>
                                        <MudExpansionPanel Class="mt-2">
                                            <TitleContent>
                                                <LabelTooltip URL=@individualParam.autoMlSeeALso Label=@individualParam.autoMlLabel FontSize="TextStyle.Body1" Text=@individualParam.autoMlComment Position="Radzen.TooltipPosition.Right"></LabelTooltip>
                                            </TitleContent>
                                            <ChildContent>
                                                @foreach (var param in individualParam.parameters)
                                                {
                                                    @if (param.ParameterType == ":single_value")
                                                    {
                                                        <MudGrid>
                                                            @if (string.IsNullOrEmpty(param.CommentPara) == false)
                                                            {
                                                                <MudItem xs="13">
                                                                    <LabelTooltip FontSize="TextStyle.H4" Text="@param.CommentPara" Position="Radzen.TooltipPosition.Left"></LabelTooltip>
                                                                </MudItem>
                                                            }
                                                            <MudItem xs="11">
                                                                <MudSelect T="ParameterValueViewModel" Class="ml-2" Label="@param.BroaderParameterLabel" Variant="MudBlazor.Variant.Outlined" @bind-SelectedValues="param.SelectedValues" ToStringFunc="p => p?.ValueLabel">
                                                                    @foreach (var paramValue in param.ParameterValues)
                                                                    {
                                                                        <MudSelectItem Value="@paramValue">
                                                                            <LabelTooltip Icon="false" Text=@paramValue.CommentValue URL=@paramValue.SeeAlsoValue FontSize="TextStyle.Body1" Position="TooltipPosition.Right" Label="@paramValue.ValueLabel"/>
                                                                        </MudSelectItem>
                                                                    }
                                                                </MudSelect>
                                                            </MudItem>
                                                        </MudGrid>
                                                    }
                                                    @if (param.ParameterType == ":list")
                                                    {
                                                        <MudGrid>
                                                            @if (string.IsNullOrEmpty(param.CommentPara) == false)
                                                            {
                                                                <MudItem xs="13">
                                                                    <LabelTooltip FontSize="TextStyle.H4" Text="@param.CommentPara" Position="Radzen.TooltipPosition.Left"></LabelTooltip>
                                                                </MudItem>
                                                            }
                                                            <MudItem xs="11">
                                                                <MudSelect T="ParameterValueViewModel" Class="ml-2" MultiSelection="true" Label="@param.BroaderParameterLabel" SelectAll="true" @bind-SelectedValues="param.SelectedValues" ToStringFunc="p => p?.ValueLabel" Variant="MudBlazor.Variant.Outlined">
                                                                    @foreach (var paramValue in param.ParameterValues)
                                                                    {
                                                                        <MudSelectItem Value="@paramValue">
                                                                            <LabelTooltip Icon="false" Text=@paramValue.CommentValue URL=@paramValue.SeeAlsoValue FontSize="TextStyle.Body1" Position="TooltipPosition.Right" Label="@paramValue.ValueLabel" />

                                                                        </MudSelectItem>
                                                                    }
                                                                </MudSelect>
                                                            </MudItem>
                                                        </MudGrid>
                                                    }
                                                    else if (param.ParameterType == ":integer")
                                                    {
                                                        <MudGrid>
                                                            @if (string.IsNullOrEmpty(param.CommentPara) == false)
                                                            {
                                                                <MudItem xs="13">
                                                                    <LabelTooltip FontSize="TextStyle.H4" Text="@param.CommentPara" Position="Radzen.TooltipPosition.Left"></LabelTooltip>
                                                                </MudItem>
                                                            }
                                                            <MudItem xs="11">
                                                                <MudNumericField T="int?" Class="ml-2" Label="@param.BroaderParameterLabel" Variant="MudBlazor.Variant.Outlined" @bind-Value="@param.IntegerValue" />
                                                            </MudItem>
                                                        </MudGrid>
                                                    }
                                                }
                                            </ChildContent>
                                        </MudExpansionPanel>
                                    </MudExpansionPanels>
                                }
                            }
                        </ChildContent>
                    </MudExpansionPanel>
                </MudExpansionPanels>
            </MudItem>
        }
    </MudGrid>

</MudStack>

@code
{
    [Parameter]
    public GetDatasetResponseDto Dataset { get; set; }

    [Parameter]
    public CreateTrainingRequestDto StartTrainingDto { get; set; }
    [Parameter]
    public EventCallback<CreateTrainingRequestDto> StartTrainingDtoChanged { get; set; }

    async Task UpdateStartTrainingDto()
    {
        await StartTrainingDtoChanged.InvokeAsync(StartTrainingDto);
    }

    private GetTasksForDatasetTypeResponseDto _compatibleTasks;
    private List<AutoMlParameterDto> _availableParameters;
    private List<ParameterObject> _intersectedParams = new();
    private List<(string autoMlLabel, string autoMlComment, string autoMlSeeALso, List<ParameterObject> parameters)> _individualParams = new();
    private List<string> _columnNames;

    private readonly ChipSet.ChipSetViewModel _mlLibsViewModel = new();
    private readonly ChipSet.ChipSetViewModel _autoMlSolutionsViewModel = new();
    private readonly ChipSet.ChipSetViewModel _strategiesViewModel = new();

    private readonly ParameterIntersector _intersector;

    public TaskConfiguration()
    {
        _intersector = new ParameterIntersector(() => _availableParameters, _autoMlSolutionsViewModel.SelectedIds.Count);
    }

    public IEnumerable<string> SelectedTargets
    {
        get
        {
            return _selectedTargets;
        }
        set
        {
            _selectedTargets = value;
            OnTargetChanged((HashSet<string>)_selectedTargets);
        }
    }

    private IEnumerable<string> _selectedTargets;

    protected async override void OnInitialized()
    {
        base.OnInitialized();
        SetupStartAutoMLConfiguration();
        _mlLibsViewModel.SelectedIdsChanged += async (_, _) => await OnMlLibrarySelectionChanged();
        _autoMlSolutionsViewModel.SelectedIdsChanged += async (_, _) => await OnAutoMlSolutionSelectionChanged();
        _strategiesViewModel.SelectedIdsChanged += async (_, _) => await OnStrategySelectionChanged();
        await LoadData();
    }

    private async void OnRuntimeValueChanged(int e)
    {
        StartTrainingDto.Configuration.RuntimeLimit = e;

        await OnMlLibrarySelectionChanged();
    }

    //Updates the Parameters in the Configuration when the selected values are changed in the frontend.
    private async void UpdateParemetersInRequest()
    {
        var paramList = _intersectedParams
            .Select(p => new ParameterDto
            {
                Iri = p.ParameterIri,
                Values = p.IntegerValue != null
                        ? new List<string> { p.IntegerValue.ToString() }
                            : p.SelectedValues.Select(v => v.ValueIri).ToList()
            })
            .ToList();

        var individualParamsList = _individualParams
        .Select(ip => ip.parameters.Select(p => new ParameterDto
        {
            Iri = p.ParameterIri,
            Values = p.IntegerValue != null
                            ? new List<string> { p.IntegerValue.ToString() }
                                    : p.SelectedValues.Select(v => v.ValueIri).ToList()
        }).ToList()).ToList();

        foreach (List<ParameterDto> individualParamItem in individualParamsList)
        {
            paramList.AddRange(individualParamItem);
        }
        StartTrainingDto.Configuration.Parameters = paramList;

        await UpdateStartTrainingDto();
    }

    /*
    Gets triggered when the wizard is initialized.
    Initial setup of the configuration.
    */
    private async void SetupStartAutoMLConfiguration()
    {
        _columnNames = new List<string>();

        if ((Dataset.Dataset.Type.ID == ":tabular") || (Dataset.Dataset.Type.ID == ":text") || (Dataset.Dataset.Type.ID == ":time_series") || (Dataset.Dataset.Type.ID == ":time_series_longitudinal"))
        {
            List<string> targets = new List<string>();
            foreach (KeyValuePair<string, ColumnSchemaDto> pair in StartTrainingDto.Schema)
            {
                if (string.IsNullOrEmpty(pair.Value.RoleSelected.ID) || (pair.Value.RoleSelected.ID != ":ignore") && (pair.Value.RoleSelected.ID != ":index"))
                {
                    _columnNames.Add(pair.Key);
                }
                if (pair.Value.RoleSelected.ID == ":target")
                {
                    targets.Add(pair.Key);
                }
            }
            SelectedTargets = new HashSet<string>(targets);
        }
        StartTrainingDto.Configuration.RuntimeLimit = 5;
        StartTrainingDto.Configuration.Metric = ":accuracy";
        await UpdateStartTrainingDto();
    }

    /*
    Gets triggered on the initial start of the wizard.
    Loads the possible Tasks for the according data.
    */
    private async Task LoadData()
    {
        try
        {
            GetTasksForDatasetTypeRequestDto taskRequest = new GetTasksForDatasetTypeRequestDto { DatasetType = Dataset.Dataset.Type.ID };
            var apiResponse = await apiClient.GetTasksForDatasetType(taskRequest);

            HandleApiResponseWrapper(apiResponse, () => _compatibleTasks = apiResponse.Result);
        }
        catch (Exception ex)
        {
            viewNotifier.Show(ex.GetBaseException().Message, ViewNotifierType.Error, L["Operation Failed"]);
        }
    }

    /*
    Task thet gets triggered when the auto ML solutions are changed.
    Refreshes the intersected & individual parameters.
    */
    private async Task RefreshParameters()
    {
        var taskIri = StartTrainingDto.Configuration.Task;
        var selectedAutoMls = StartTrainingDto.Configuration.SelectedAutoMlSolutions;
        var apiResponse = await apiClient.GetAutoMlParameters(new GetAutoMlParametersRequestDto { AutoMls = selectedAutoMls, TaskIri = taskIri });
        HandleApiResponseWrapper(
            apiResponse,
            () =>
            {
                _availableParameters = apiResponse.Result.AutoMlParameters;
                if (_availableParameters.GroupBy(p => p.AutoML.ID) == null)
                {
                    return;
                }
                _intersectedParams = ReplaceIntersectedParameter(_intersector.GetIntersectedParameters().ToList());
                foreach (var param in _intersectedParams)
                {
                    param.SelectedValuesChanged += (_, _) => UpdateParemetersInRequest();
                }


                var paramsGroupedBySolution = _availableParameters.GroupBy(p => p.AutoML.ID);

                var newIndividualParams = new List<(string, string, string, List<ParameterObject>)>();
                if (paramsGroupedBySolution.Count() > 0)
                {
                    foreach (var group in paramsGroupedBySolution)
                    {
                        if (_autoMlSolutionsViewModel.AvailableChips.SingleOrDefault(c => c.Id == group.Key) == null)
                        {
                            //Sometimes the refresh is slower that the list refresh, exclude a chip if it is not available in the selection
                            continue;
                        }
                        var autoMlLabel = _autoMlSolutionsViewModel.AvailableChips.SingleOrDefault(c => c.Id == group.Key).Label;
                        var autoMlComment = _autoMlSolutionsViewModel.AvailableChips.SingleOrDefault(c => c.Id == group.Key).Comment;
                        var autoMlSeeAlso = _autoMlSolutionsViewModel.AvailableChips.SingleOrDefault(c => c.Id == group.Key).ImageUrl;

                        newIndividualParams.Add(
                            (
                                autoMlLabel,
                                autoMlComment,
                                autoMlSeeAlso,
                                group
                                    .GroupBy(param => param.Parameter.ID)
                                    .Select(p => CreateParameterObjectFromGroupedParameterDto(p, autoMlLabel))
                                    .ToList()
                            )
                        );
                    }
                    _individualParams.Clear();
                    var selectedAutoMls = _autoMlSolutionsViewModel.AvailableChips.Where(c => c.IsSelected);
                    if (paramsGroupedBySolution.Count() > 1 || (selectedAutoMls.Count() > 1 && paramsGroupedBySolution.Count() == 1))
                    {
                        _individualParams = new List<(string, string, string, List<ParameterObject>)>(newIndividualParams);
                    }
                    newIndividualParams = null;
                    foreach (var individualParam in _individualParams)
                    {
                        foreach (var param in individualParam.parameters)
                        {
                            param.SelectedValuesChanged += (_, _) => UpdateParemetersInRequest();
                        }
                    }
                }
            },
            errorMessageKey: "Fetching available parameters failed");
    }

    /*
    Creation of the parameter objects from the the data received from the ontology.
    Mainly restructuring of the data.
    */
    private ParameterObject CreateParameterObjectFromGroupedParameterDto(IGrouping<string, AutoMlParameterDto> parameterGroup, string autoMlLabel)
    {
        var firstInstanceWithIri = parameterGroup.First();
        var result = new ParameterObject
        {
            BroaderParameterLabel = firstInstanceWithIri.Broader.Properties["skos:prefLabel"],
            ParameterIri = parameterGroup.Key,
            ParameterLabel = firstInstanceWithIri.Parameter.Properties["skos:prefLabel"],
            ParameterType = firstInstanceWithIri.ParameterType.ID,
            SeeAlsoPara = firstInstanceWithIri.Parameter.Properties.ContainsKey("rdfs:seeAlso") ? firstInstanceWithIri.Parameter.Properties["rdfs:seeAlso"] : "",
            CommentPara = firstInstanceWithIri.Parameter.Properties.ContainsKey("rdfs:comment") ? firstInstanceWithIri.Parameter.Properties["rdfs:comment"] : ""
        };

        if (!firstInstanceWithIri.IsScalar)
        {
            result.ParameterValues = parameterGroup.Select(param => new ParameterValueViewModel
            {
                ValueIri = param.Value.ID,
                ValueLabel = param.Value.Properties["skos:prefLabel"],
                CommentValue = param.Parameter.Properties.ContainsKey("rdfs:comment") ? param.Parameter.Properties["rdfs:comment"] : "",
                SeeAlsoValue = param.Parameter.Properties.ContainsKey("rdfs:seeAlso") ? param.Parameter.Properties["rdfs:seeAlso"] : ""
            }).ToList();
            if (_individualParams.Any() && _individualParams.Where(i => i.autoMlLabel == autoMlLabel).Any())
            {
                var individualParamsList = _individualParams.Where(i => i.autoMlLabel == autoMlLabel).Select(p => p.parameters).First();
                IEnumerable<ParameterValueViewModel> selectedValues = new List<ParameterValueViewModel>();
                if (individualParamsList.Where(p => p.ParameterIri == parameterGroup.Key).Select(p => p.SelectedValues).Any())
                {
                    selectedValues = individualParamsList.Where(p => p.ParameterIri == parameterGroup.Key).Select(p => p.SelectedValues).First();
                }
                result.SelectedValues = new List<ParameterValueViewModel>(result.ParameterValues.Where(p => selectedValues.Where(s => s.ValueIri == p.ValueIri).Any()).ToList());
            }
        }
        return result;
    }

    /*
    Function that gets triggered when the selection of the ML Task gets changed.
    Set the task in the configuration.
    Load ML libs for the fitting task and set the data for the chipsets.
    */
    private async void OnMlTaskSelectionChanged(string task)
    {
        if (string.IsNullOrEmpty(task))
        {
            return;
        }
        StartTrainingDto.Configuration.Task = task;
        try
        {
            Dictionary<string, string> dictionary = new Dictionary<string, string>
            {
                { "task", StartTrainingDto.Configuration.Task }
            };
            await UpdateStartTrainingDto();
            /** Configuration = dictionary is currently dummy */
            //GetCompatibleAutoMlSolutionsRequestDto compatibleAutoMlRequest = new GetCompatibleAutoMlSolutionsRequestDto { Configuration = dictionary };

            //ApiResponseDto apiResponse = await apiClient.GetCompatibleAutoMlSolutions(compatibleAutoMlRequest);

            //if (apiResponse.IsSuccessStatusCode)
            //{
            //    _compatibleAutoMls = Newtonsoft.Json.JsonConvert.DeserializeObject<GetCompatibleAutoMlSolutionsResponseDto>(apiResponse.Result.ToString());
            //    StateHasChanged();
            //    viewNotifier.Show(apiResponse.Message, ViewNotifierType.Success, L["AutoMlSolution Operation Successful"]);
            //}
            //else
            //{
            //    viewNotifier.Show(apiResponse.Message + " : " + apiResponse.StatusCode, ViewNotifierType.Error, L["AutoMlSolution Operation Failed"]);
            //}

            GetMlLibrariesForTaskRequestDto supportedMlLibrariesRequest = new GetMlLibrariesForTaskRequestDto { Task = StartTrainingDto.Configuration.Task };
            var apiResponse = await apiClient.GetMlLibrariesForTask(supportedMlLibrariesRequest);

            HandleApiResponseWrapper(apiResponse, () =>
                 _mlLibsViewModel.SetAvailableChips(
                    apiResponse.Result.MlLibraries
                        .Select(ConvertObjectInfoToChip)),
            errorMessageKey: "SupportedMlLibraries Operation Failed");

            var suggestedRuntimeResponse = await apiClient.GetSuggestedTrainingRuntime(new GetTrainingSuggestedRuntimeRequestDto() { DatasetId = Dataset.Dataset.Id, Task = StartTrainingDto.Configuration.Task });

            if (suggestedRuntimeResponse.IsSuccessStatusCode)
            {
                GetTrainingSuggestedRuntimeResponseDto response = Newtonsoft.Json.JsonConvert.DeserializeObject<GetTrainingSuggestedRuntimeResponseDto>(suggestedRuntimeResponse.Result.ToString());
                StartTrainingDto.Configuration.RuntimeLimit = response.SuggestedRuntime;
            }
            else
            {
                viewNotifier.Show(suggestedRuntimeResponse.Message + " : " + suggestedRuntimeResponse.StatusCode, ViewNotifierType.Error, L["Operation Failed"]);
            }
        }
        catch (Exception ex)
        {
            viewNotifier.Show(ex.GetBaseException().Message, ViewNotifierType.Error, L["Operation Failed"]);
        }
    }

    private (string id, string label, string toolTip, bool isSelected, string comment, string imageUrl) ConvertObjectInfoToChip(ObjectInfomationDto objectInfo) =>
        (objectInfo.ID, objectInfo.Properties.GetValueOrDefault("skos:prefLabel"), objectInfo.Properties.GetValueOrDefault("rdfs:seeAlso"), true, objectInfo.Properties.GetValueOrDefault("rdfs:comment"), "");


    /*
    Task that gets triggered when the ML Library selection changes.
     Set the selected ML libs in the configuration.
     Get the available ML solutions with the according ML libs.
     Trigger the event to update the available strategies.
    */
    private async Task OnMlLibrarySelectionChanged()
    {
        try
        {
            Dictionary<string, string> dictionary = new Dictionary<string, string>
        {
                { "task", StartTrainingDto.Configuration.Task },
                { "runtimeLimit", StartTrainingDto.Configuration.RuntimeLimit.ToString() }
            };

            List<string> libraries = _mlLibsViewModel.SelectedIds.ToList();
            StartTrainingDto.Configuration.SelecctedMlLibraries = _mlLibsViewModel.SelectedIds.ToList();

            await UpdateStartTrainingDto();
            if (libraries.Any())
            {
                dictionary.Add("library", JsonConvert.SerializeObject(libraries));
            }
            GetAutoMlSolutionsForConfigurationRequestDto compatibleAutoMlRequest = new GetAutoMlSolutionsForConfigurationRequestDto { Configuration = dictionary };
            var apiResponse = await apiClient.GetAutoMlSolutionsForConfiguration(compatibleAutoMlRequest);

            HandleApiResponseWrapper(apiResponse, () =>
                _autoMlSolutionsViewModel.SetAvailableChips(apiResponse.Result.AutoMlSolutions.Select(ConvertObjectInfoToChip))
            );

            await UpdateAvailableStrategies(dictionary);
        }
        catch (Exception ex)
        {
            viewNotifier.Show(ex.GetBaseException().Message, ViewNotifierType.Error, L["Operation Failed"]);
        }
    }

    /*
    Task that gets triggered when the ML Library selection gets changed.
    Updates the available strategies for the selected libraries.
    */
    private async Task UpdateAvailableStrategies(Dictionary<string, string> dictionary)
    {
        int runtime_limit = StartTrainingDto.Configuration.RuntimeLimit;
        GetAvailableStrategiesRequestDto availableStrategiesRequest = new GetAvailableStrategiesRequestDto { Configuration = dictionary, DatasetId = Dataset.Dataset.Id };
        var availableStrategiesResponse = await apiClient.GetAvailableStrategies(availableStrategiesRequest);

        HandleApiResponseWrapper(availableStrategiesResponse, () =>
            _strategiesViewModel.SetAvailableChips(availableStrategiesResponse.Result.Strategies.Select(s => (s.Id, s.Title, "", false, s.Description, "")))

        );
    }

    private void HandleApiResponseWrapper<T>(ApiResponseDto<T> apiResponse, Action successAction, string errorMessageKey = "Operation Failed", string successMessageKey = "Operation Successful")
    {
        if (apiResponse.IsSuccessStatusCode)
        {
            successAction();
            StateHasChanged();
        }
        else
        {
            viewNotifier.Show(apiResponse.Message + " : " + apiResponse.StatusCode, ViewNotifierType.Error, L[errorMessageKey]);
        }
    }

    /*
    Task that gets triggered when the selection of the AuotML gets changed.
    Sets the selected AutoMLs in the configuration to the in the frontend selected AutoMLs.
    Triggers the refresh of the available parameters.
    */
    private async Task OnAutoMlSolutionSelectionChanged()
    {
        StartTrainingDto.Configuration.SelectedAutoMlSolutions = _autoMlSolutionsViewModel.SelectedIds.ToList();

        await UpdateStartTrainingDto();
        await RefreshParameters();
    }

    /*
    Task that gets triggered when the strategy gets changed.
    Set the enabled strategies to the in the frontend selected strategies.
    */
    private Task OnStrategySelectionChanged()
    {
        StartTrainingDto.Configuration.EnabledStrategies = _strategiesViewModel.SelectedIds.ToList();
        return UpdateStartTrainingDto();
    }

    /*
    Function that gets triggered when the target column of the dataset gets changed.
    Sets the target to the in the frontend selected values
    */
    private async void OnTargetChanged(HashSet<string> values)
    {
        //We need to update the schema configuration with appropriated target values
        foreach (var item in StartTrainingDto.Schema)
        {
            if (values.Contains(item.Key))
            {
                item.Value.RoleSelected.ID = ":target";
            }
            else
            {
                if ((!string.IsNullOrEmpty(item.Value.RoleSelected.ID)) && (item.Value.RoleSelected.ID == ":target"))
                {
                    item.Value.RoleSelected.ID = null;
                }
            }
        }
        await UpdateStartTrainingDto();
    }

    /*
    Set the selectedValues of the intersected parameter because the intersected parameter list got replaced and therefore the selection of the parameter got reseted
    - intersectedParamsNew: List of the intersected parameters
    returns:
    - List of the intersected parameters with the already selected values
    */
    private List<ParameterObject> ReplaceIntersectedParameter(List<ParameterObject> intersectedParamsNew)
    {
        foreach (ParameterObject intersectedParam in intersectedParamsNew)
        {
            if (_intersectedParams.Where(p => p.ParameterIri == intersectedParam.ParameterIri).Any())
            {
                try
                {
                    //TODO watch out for int values, does this pose an issue for intersections?
                    List<ParameterValueViewModel> selectedValueList = _intersectedParams.Where(p => p.ParameterIri == intersectedParam.ParameterIri).First().SelectedValues.Where(s => intersectedParam.ParameterValues.Where(pv => pv.ValueIri == s.ValueIri).Any()).ToList();
                    if (intersectedParam.ParameterValues != null)
                    {
                        intersectedParam.SelectedValues = intersectedParam.ParameterValues.Where(p => selectedValueList.Where(s => s.ValueIri == p.ValueIri).Any()).ToList();
                    }
                }
                catch (Exception ex)
                {
                    throw ex;
                }
            }
        }
        return intersectedParamsNew;
    }

    /*
    Class for the parameter values
    - ValueIri: Iri of the stored parameter value
    - ValueLabel: Label of the stored parameter value
    Example: ValueIri -> ":accuracy" | ValueLabel -> "accuracy"
    */
    public class ParameterValueViewModel
    {
        public string ValueIri { get; set; }
        public string ValueLabel { get; set; }
        public string CommentValue { get; set; }
        public string SeeAlsoValue { get; set; }
    }

    /*
    Class that contains all informations about a parameter.
    - BroaderParameterLabel: Label of the broader parameter type (e.g. parameter label: "metric autokeras" -> broader label: "metric")
    - ParameterIri: Iri of the parameter
    - ParameterLabel: Label of the parameter
    - ParameterType: Type of the parameter
    - ParameterValues: List of Values that the parameter can have
    - _selectedValues: private list of the selected parameter values
    - SelectedValues: public visibility of the selected parameter values
    - _integerValue: private integer value that the parameter has
    - IntegerValue: public visibility of the selected integer value
    */
    public class ParameterObject
    {
        public event EventHandler SelectedValuesChanged;
        public string BroaderParameterLabel { get; set; }
        public string ParameterIri { get; set; }
        public string ParameterLabel { get; set; }
        public string ParameterType { get; set; }
        public string CommentPara { get; set; }
        public string SeeAlsoPara { get; set; }
        public List<ParameterValueViewModel> ParameterValues { get; set; } = new();
        private IEnumerable<ParameterValueViewModel> _selectedValues = new List<ParameterValueViewModel>();
        public IEnumerable<ParameterValueViewModel> SelectedValues
        {
            get => _selectedValues;
            set
            {
                _selectedValues = value;
                SelectedValuesChanged?.Invoke(this, EventArgs.Empty);
            }
        }

        private int? _integerValue;
        public int? IntegerValue
        {
            get => _integerValue;
            set
            {
                if (_integerValue == value)
                {
                    return;
                }
                _integerValue = value;
                SelectedValuesChanged?.Invoke(this, EventArgs.Empty);
            }
        }
    }
}
