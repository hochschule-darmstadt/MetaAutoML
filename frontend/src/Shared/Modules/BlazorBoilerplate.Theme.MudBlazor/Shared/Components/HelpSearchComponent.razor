@using System.ComponentModel.DataAnnotations
@using BlazorBoilerplate.Shared.Models
@namespace BlazorBoilerplate.Theme.Material.Demo.Shared.Components
@inject NavigationManager navigationManager
@inject IHelpSearch helpSearch
@using MudBlazor

<MudAutocomplete Margin="Margin.Dense" Dense="true" Label="Help search ..." @bind-Value="choice.State" Required="false" @bind-Text="@searchInputText"
				 SearchFunc="@SearchAsync" Immediate="true" CoerceValue="@coerceValue" ResetValueOnEmptyText="true"
				 AdornmentIcon="@Icons.Material.Filled.Search" AdornmentColor="Color.Primary" T="HelpSearchOption"
				 For="@(() => choice.State)" ListClass="SearchBarList" PopoverClass="SearchBarOverlay">
	<ItemTemplate Context="e">
		<MudIcon Style="font-size:15px" Class="d-inline" Icon="@GetIconOfOrigin(e.OriginType)" Title="Favorite" />
		<MudText Style="font-size:15px" Class="d-inline">
			<MudHighlighter Text="@e.Text" HighlightedText="@searchInputText" />
		</MudText>
	</ItemTemplate>
</MudAutocomplete>

@if (!string.IsNullOrEmpty(choice.State.Text))
{
	redirectOnSearch();
}

@code {
	private string searchInputText;
    [Parameter]
    public string query { get; set; }

    [Parameter]
    public bool HelpSite { get; set; }

	[Parameter]
	public EventCallback OnStatesChanged { get; set; }

	private void UpdateStates()
	{
		OnStatesChanged.InvokeAsync();
	}

    [CascadingParameter]
    Task<AuthenticationState> authenticationStateTask { get; set; }

    private MudForm form;
    private bool coerceValue;
    private bool success;
    private Choice choice = new();
    private EditContext editContext;

    protected override void OnInitialized()
    {
        editContext = new EditContext(choice);
        choice.State = new HelpSearchOption(HelpSearchResultType.HELP_ARTICLE, query);
    }

    protected override async Task OnInitializedAsync()
    {
        var user = (await authenticationStateTask).User;

        if (user.Identity.IsAuthenticated)
        {
            await helpSearch.LoadSearchCache();
            states = helpSearch.GetAllAutocompleteOptions().ToArray();
        }
    }

    private void redirectOnSearch()
    {
        if (!navigationManager.Uri.Contains("search") & !HelpSite)
        {
            query = choice.State.Text;
            navigationManager.NavigateTo($"search/{query}");
            choice.State = new HelpSearchOption(HelpSearchResultType.HELP_ARTICLE, null);
        }
    }

    public static HelpSearchOption[] states =
    {
		new HelpSearchOption(HelpSearchResultType.HELP_ARTICLE, "Loading ...")
	};

    private async Task<IEnumerable<HelpSearchOption>> SearchAsync(string value)
    {
		if (string.IsNullOrEmpty(value))
		{
			return states;
		}
		return states.Where(x => x.Text.Contains(value, StringComparison.InvariantCultureIgnoreCase));
	}

    private string GetIconOfOrigin(HelpSearchResultType origin)
    {
        switch (origin)
        {
            case HelpSearchResultType.ONTOLOGY:
            {
                return Icons.Material.Filled.Web;
            }
            case HelpSearchResultType.HELP_ARTICLE:
            {
                return Icons.Material.Filled.Article;
            }
            default:
            {
                return null;
            }
        }
    }

	public class Choice
	{
		[Required]
		[State]
		public HelpSearchOption State { get; set; }
	}

	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter)]
	public sealed class StateAttribute : ValidationAttribute
	{
		protected override ValidationResult IsValid(object value, System.ComponentModel.DataAnnotations.ValidationContext validationContext)
		{
            if(value == null)
            {
                return new ValidationResult("Value is null");
            }

			if (!states.Contains(value))
			{
				return new ValidationResult("This is an incorrect value", new[] { validationContext.MemberName });
			}

			if (validationContext is null)
			{
				throw new ArgumentNullException(nameof(validationContext));
			}

			return null;
		}
	}
}
